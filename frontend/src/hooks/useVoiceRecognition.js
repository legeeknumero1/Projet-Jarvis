import { useState, useRef, useCallback, useEffect } from 'react';

/**
 * Hook personnalis√© pour la reconnaissance vocale
 * Optimis√© pour les performances et la gestion des erreurs
 */
export const useVoiceRecognition = ({
  isConnected = false,
  interactionMode = 'hybrid',
  onTranscriptionComplete,
  onError
}) => {
  const [isListening, setIsListening] = useState(false);
  const recognitionRef = useRef(null);
  const isComponentMountedRef = useRef(true);
  const recognitionCleanupTimerRef = useRef(null);

  // Configuration de la reconnaissance vocale
  const initializeRecognition = useCallback(() => {
    const hasSpeechRecognition = () => {
      try {
        return !!(window.SpeechRecognition || window.webkitSpeechRecognition);
      } catch (error) {
        console.warn('‚ö†Ô∏è Erreur v√©rification SpeechRecognition:', error);
        return false;
      }
    };
    
    if (hasSpeechRecognition()) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognitionRef.current = new SpeechRecognition();
      
      // Configuration optimis√©e pour √©viter erreurs r√©seau
      recognitionRef.current.continuous = false;
      recognitionRef.current.interimResults = true;
      recognitionRef.current.lang = 'fr-FR';
      recognitionRef.current.maxAlternatives = 1;
      
      recognitionRef.current.onstart = () => {
        console.log('‚úÖ Reconnaissance vocale d√©marr√©e avec succ√®s');
        setIsListening(true);
      };
      
      recognitionRef.current.onresult = (event) => {
        let transcript = '';
        let interimTranscript = '';
        
        for (let i = 0; i < event.results.length; i++) {
          if (event.results[i].isFinal) {
            transcript += event.results[i][0].transcript;
          } else {
            interimTranscript += event.results[i][0].transcript;
          }
        }
        
        if (transcript.trim()) {
          console.log('üó£Ô∏è Transcription finale:', transcript);
          recognitionRef.current.stop();
          setIsListening(false);
          
          if (onTranscriptionComplete) {
            onTranscriptionComplete(transcript, interimTranscript);
          }
        }
      };
      
      recognitionRef.current.onend = () => {
        if (isComponentMountedRef.current) {
          console.log('üéØ Reconnaissance vocale termin√©e');
          setIsListening(false);
          
          if (recognitionCleanupTimerRef.current) {
            clearTimeout(recognitionCleanupTimerRef.current);
            recognitionCleanupTimerRef.current = null;
          }
          
          // En mode vocal pur, red√©marrer automatiquement avec protection memory leak
          if (interactionMode === 'voice-only' && isComponentMountedRef.current) {
            setTimeout(() => {
              if (isComponentMountedRef.current) {
                console.log('üîÑ Red√©marrage auto reconnaissance (mode vocal)');
                try {
                  if (recognitionRef.current && !isListening) {
                    recognitionRef.current.start();
                  }
                } catch (error) {
                  console.warn('‚ö†Ô∏è Impossible de red√©marrer reconnaissance:', error);
                }
              }
            }, 3000);
          }
        }
      };
      
      recognitionRef.current.onerror = (event) => {
        if (isComponentMountedRef.current) {
          console.error('üî• Erreur reconnaissance vocale:', event.error);
          setIsListening(false);
          
          if (recognitionCleanupTimerRef.current) {
            clearTimeout(recognitionCleanupTimerRef.current);
            recognitionCleanupTimerRef.current = null;
          }
          
          // Gestion des erreurs sp√©cifiques
          let errorMessage = 'Erreur de reconnaissance vocale';
          
          switch(event.error) {
            case 'not-allowed':
              errorMessage = '‚ùå Acc√®s au microphone refus√©. Autorisez l\'acc√®s dans les param√®tres du navigateur.';
              alert(errorMessage);
              break;
            case 'no-speech':
              console.log('üîá Aucune parole d√©tect√©e, red√©marrage possible');
              break;
            case 'network':
              console.error('üåê Erreur r√©seau reconnaissance vocale - Tentative en mode non-continu');
              if (recognitionRef.current) {
                recognitionRef.current.continuous = false;
              }
              break;
            case 'service-not-allowed':
              console.error('üö´ Service de reconnaissance vocale bloqu√©');
              break;
            case 'bad-grammar':
              console.error('üìù Grammaire de reconnaissance invalide');
              break;
            default:
              console.error('üî• Erreur inconnue:', event.error);
          }
          
          if (onError) {
            onError(event.error, errorMessage);
          }
        }
      };
    }
  }, [interactionMode, onTranscriptionComplete, onError, isListening]);

  // Toggle de la reconnaissance vocale
  const toggleVoiceRecognition = useCallback(() => {
    if (!recognitionRef.current) {
      console.error('‚ùå Reconnaissance vocale non support√©e');
      if (onError) {
        onError('not-supported', '‚ùå Reconnaissance vocale non support√©e par ce navigateur');
      }
      return;
    }
    
    try {
      if (isListening) {
        console.log('üõë Arr√™t reconnaissance vocale');
        recognitionRef.current.abort();
        setIsListening(false);
      } else {
        console.log('üé§ D√©marrage reconnaissance vocale');
        if (recognitionRef.current && !isListening) {
          recognitionRef.current.start();
        } else {
          console.warn('‚ö†Ô∏è Reconnaissance d√©j√† en cours ou ref invalide');
        }
      }
    } catch (error) {
      console.error('üî• Erreur toggle reconnaissance:', error);
      setIsListening(false);
      
      // Tentative de r√©cup√©ration
      if (error.name === 'InvalidStateError') {
        console.log('üîÑ Tentative de r√©cup√©ration InvalidStateError');
        setTimeout(() => {
          try {
            recognitionRef.current?.start();
          } catch (retryError) {
            console.error('üö´ √âchec r√©cup√©ration:', retryError);
            if (onError) {
              onError('recovery-failed', 'Impossible de red√©marrer la reconnaissance vocale');
            }
          }
        }, 1000);
      }
    }
  }, [isListening, onError]);

  // Initialization effect
  useEffect(() => {
    initializeRecognition();
    
    return () => {
      isComponentMountedRef.current = false;
      
      if (recognitionCleanupTimerRef.current) {
        clearTimeout(recognitionCleanupTimerRef.current);
      }
      
      // Nettoyage s√©curis√©
      if (recognitionRef.current) {
        try {
          recognitionRef.current.stop();
          recognitionRef.current.onstart = null;
          recognitionRef.current.onresult = null;
          recognitionRef.current.onend = null;
          recognitionRef.current.onerror = null;
        } catch (error) {
          console.warn('‚ö†Ô∏è Erreur nettoyage reconnaissance:', error);
        }
      }
    };
  }, [initializeRecognition]);

  return {
    isListening,
    toggleVoiceRecognition,
    isSupported: !!(window.SpeechRecognition || window.webkitSpeechRecognition)
  };
};