import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import './CyberpunkJarvisInterface.css';

const CyberpunkJarvisInterface = () => {
  const [messages, setMessages] = useState([]);
  const [inputMessage, setInputMessage] = useState('');
  const [isListening, setIsListening] = useState(false);
  const [isConnected, setIsConnected] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [isSpeaking, setIsSpeaking] = useState(false);
  const [autoSpeak, setAutoSpeak] = useState(false);
  const [interactionMode, setInteractionMode] = useState('hybrid'); // 'voice-only', 'text-only', 'hybrid'
  const [availableVoices, setAvailableVoices] = useState([]);
  const [selectedVoiceIndex, setSelectedVoiceIndex] = useState(0);
  const [connectionStatus, setConnectionStatus] = useState('Initialisation...');
  
  const recognitionRef = useRef(null);
  const messagesEndRef = useRef(null);
  const synthRef = useRef(null);
  
  // Configuration API
  const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';
  const TTS_API_URL = process.env.REACT_APP_TTS_URL || 'http://localhost:8002';
  
  // Test de connexion au d√©marrage
  useEffect(() => {
    testConnection();
    const interval = setInterval(testConnection, 30000); // Test toutes les 30s
    return () => clearInterval(interval);
  }, []);
  
  const testConnection = async () => {
    try {
      const response = await fetch(`${API_BASE_URL}/health`, { 
        method: 'GET',
        timeout: 5000 
      });
      if (response.ok) {
        setIsConnected(true);
        setConnectionStatus('En ligne');
      } else {
        throw new Error('Backend non accessible');
      }
    } catch (error) {
      console.error('‚ùå Connexion backend √©chou√©e:', error);
      setIsConnected(false);
      setConnectionStatus('Hors ligne');
    }
  };
  
  // Configuration synth√®se vocale et chargement des voix
  useEffect(() => {
    if ('speechSynthesis' in window) {
      synthRef.current = window.speechSynthesis;
      
      const loadVoices = () => {
        const voices = synthRef.current.getVoices();
        const frenchVoices = voices.filter(voice => 
          voice.lang.startsWith('fr') && 
          !voice.name.toLowerCase().includes('compact')
        );
        
        // S√©lectionner jusqu'√† 9 voix fran√ßaises diff√©rentes
        const selectedVoices = frenchVoices.slice(0, 9);
        setAvailableVoices(selectedVoices.length > 0 ? selectedVoices : voices.slice(0, 9));
        console.log('üó£Ô∏è Voix disponibles:', selectedVoices.length > 0 ? selectedVoices.length : voices.slice(0, 9).length);
      };
      
      // Charger les voix imm√©diatement si disponibles
      loadVoices();
      
      // √âcouter le chargement des voix (pour certains navigateurs)
      synthRef.current.onvoiceschanged = loadVoices;
    }
  }, []);
  
  // Configuration reconnaissance vocale
  useEffect(() => {
    if (window.SpeechRecognition || window.webkitSpeechRecognition) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognitionRef.current = new SpeechRecognition();
      
      recognitionRef.current.continuous = true;
      recognitionRef.current.interimResults = true;
      recognitionRef.current.lang = 'fr-FR';
      
      recognitionRef.current.onstart = () => {
        setIsListening(true);
        console.log('üé§ Reconnaissance vocale d√©marr√©e');
      };
      
      recognitionRef.current.onresult = (event) => {
        let transcript = '';
        let interimTranscript = '';
        
        for (let i = 0; i < event.results.length; i++) {
          if (event.results[i].isFinal) {
            transcript += event.results[i][0].transcript;
          } else {
            interimTranscript += event.results[i][0].transcript;
          }
        }
        
        // En mode vocal uniquement, ne pas afficher le texte interm√©diaire
        if (interactionMode !== 'voice-only') {
          setInputMessage(transcript || interimTranscript);
        }
        
        if (transcript.trim()) {
          console.log('üó£Ô∏è Transcription finale:', transcript);
          
          if (interactionMode === 'voice-only') {
            // En mode vocal pur, envoyer directement sans afficher le texte
            recognitionRef.current.stop();
            setIsListening(false);
            setTimeout(() => handleSendMessage(transcript), 300);
          } else {
            // En mode hybrid/text, afficher et permettre √©dition
            setInputMessage(transcript);
            recognitionRef.current.stop();
            setIsListening(false);
            
            // En mode hybrid, envoyer automatiquement apr√®s un d√©lai
            if (interactionMode === 'hybrid') {
              setTimeout(() => handleSendMessage(transcript), 300);
            }
          }
        }
      };
      
      recognitionRef.current.onend = () => {
        setIsListening(false);
        console.log('üé§ Reconnaissance vocale termin√©e');
      };
      
      recognitionRef.current.onerror = (event) => {
        console.error('üî• Erreur reconnaissance vocale:', event.error);
        setIsListening(false);
      };
    }
    
    return () => {
      if (recognitionRef.current) {
        recognitionRef.current.abort();
      }
    };
  }, []);
  
  // Auto-scroll
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };
  
  useEffect(() => {
    scrollToBottom();
  }, [messages]);
  
  // Synth√®se vocale TTS
  const speakMessage = async (text) => {
    if (!text || isSpeaking) return;
    
    setIsSpeaking(true);
    
    // Utiliser UNIQUEMENT la synth√®se vocale navigateur pour une voix naturelle
    if (synthRef.current && 'speechSynthesis' in window) {
      try {
        // Arr√™ter toute synth√®se en cours
        synthRef.current.cancel();
        
        // Attendre que les voix soient charg√©es
        const loadVoices = () => {
          return new Promise((resolve) => {
            let voices = synthRef.current.getVoices();
            if (voices.length > 0) {
              resolve(voices);
            } else {
              synthRef.current.onvoiceschanged = () => {
                voices = synthRef.current.getVoices();
                resolve(voices);
              };
            }
          });
        };
        
        const voices = await loadVoices();
        
        // Utiliser la voix s√©lectionn√©e par l'utilisateur
        let selectedVoice = null;
        if (availableVoices.length > 0 && selectedVoiceIndex < availableVoices.length) {
          selectedVoice = availableVoices[selectedVoiceIndex];
        } else {
          // Fallback: chercher une voix fran√ßaise
          const frenchVoices = voices.filter(voice => 
            voice.lang.startsWith('fr') && 
            !voice.name.toLowerCase().includes('compact')
          );
          selectedVoice = frenchVoices[0] || voices[0];
        }
        
        const utterance = new SpeechSynthesisUtterance(text.substring(0, 300));
        utterance.lang = 'fr-FR';
        utterance.rate = 0.85;
        utterance.pitch = 1.0;
        utterance.volume = 0.9;
        
        if (selectedVoice) {
          utterance.voice = selectedVoice;
          console.log('üó£Ô∏è Voix s√©lectionn√©e:', selectedVoice.name, selectedVoice.lang);
        }
        
        utterance.onstart = () => {
          console.log('üîä Synth√®se vocale d√©marr√©e');
        };
        
        utterance.onend = () => {
          console.log('üîä Synth√®se vocale termin√©e');
          setIsSpeaking(false);
        };
        
        utterance.onerror = (error) => {
          console.error('üî• Erreur synth√®se vocale:', error);
          setIsSpeaking(false);
        };
        
        synthRef.current.speak(utterance);
        
      } catch (error) {
        console.error('üî• Erreur TTS:', error);
        setIsSpeaking(false);
      }
    } else {
      console.warn('‚ö†Ô∏è Synth√®se vocale non support√©e');
      setIsSpeaking(false);
    }
    
    // Timeout de s√©curit√©
    setTimeout(() => {
      if (isSpeaking) {
        synthRef.current?.cancel();
        setIsSpeaking(false);
      }
    }, 30000);
  };
  
  // Envoi de message
  const handleSendMessage = async (message) => {
    const messageToSend = message || inputMessage;
    if (!messageToSend.trim() || !isConnected) return;
    
    const sanitizedMessage = messageToSend.trim().substring(0, 5000);
    
    setIsLoading(true);
    setInputMessage('');
    
    // Ajouter message utilisateur
    const userMessage = {
      id: Date.now(),
      type: 'user',
      content: sanitizedMessage,
      timestamp: new Date()
    };
    
    setMessages(prev => [...prev, userMessage]);
    
    try {
      console.log('üì§ Envoi message vers backend...');
      const response = await fetch(`${API_BASE_URL}/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: sanitizedMessage,
          user_id: 'enzo'
        })
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      console.log('üì• R√©ponse backend:', data);
      
      // Ajouter r√©ponse assistant
      const assistantMessage = {
        id: Date.now() + 1,
        type: 'assistant',
        content: data.response || 'Pas de r√©ponse du syst√®me.',
        timestamp: new Date()
      };
      
      setMessages(prev => [...prev, assistantMessage]);
      
      // Synth√®se vocale automatique si activ√©e
      if (autoSpeak) {
        setTimeout(() => {
          speakMessage(data.response);
        }, 1000);
      }
      
    } catch (error) {
      console.error('‚ùå Erreur chat:', error);
      
      const errorMessage = {
        id: Date.now() + 1,
        type: 'assistant',
        content: `‚ö†Ô∏è Erreur de connexion: ${error.message}. V√©rifiez que le backend Jarvis est d√©marr√© sur le port 8000.`,
        timestamp: new Date(),
        isError: true
      };
      
      setMessages(prev => [...prev, errorMessage]);
    }
    
    setIsLoading(false);
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    handleSendMessage();
  };
  
  const toggleVoiceRecognition = () => {
    if (!recognitionRef.current) {
      alert('‚ùå Reconnaissance vocale non support√©e par ce navigateur');
      return;
    }
    
    if (isListening) {
      recognitionRef.current.stop();
    } else {
      recognitionRef.current.start();
    }
  };
  
  const stopSpeaking = () => {
    if (synthRef.current) {
      synthRef.current.cancel();
    }
    setIsSpeaking(false);
  };
  
  const toggleAutoSpeak = () => {
    setAutoSpeak(!autoSpeak);
    console.log('üîä Lecture automatique:', !autoSpeak ? 'ON' : 'OFF');
  };
  
  const speakLastMessage = () => {
    const lastAssistantMessage = messages.filter(msg => msg.type === 'assistant').pop();
    if (lastAssistantMessage && lastAssistantMessage.content) {
      speakMessage(lastAssistantMessage.content);
    } else {
      console.warn('‚ö†Ô∏è Aucune r√©ponse √† lire');
    }
  };
  
  const changeInteractionMode = (mode) => {
    setInteractionMode(mode);
    console.log('üéØ Mode d‚Äôinteraction chang√©:', mode);
    
    // Ajuster comportements selon le mode
    if (mode === 'voice-only') {
      setAutoSpeak(true); // Activation automatique lecture
      setInputMessage(''); // Vider le champ de saisie
    } else if (mode === 'text-only') {
      setAutoSpeak(false); // D√©sactiver lecture automatique
      if (isListening) {
        recognitionRef.current?.stop();
      }
    }
  };
  
  const changeVoice = (direction) => {
    if (availableVoices.length === 0) return;
    
    let newIndex;
    if (direction === 'next') {
      newIndex = (selectedVoiceIndex + 1) % availableVoices.length;
    } else {
      newIndex = selectedVoiceIndex === 0 ? availableVoices.length - 1 : selectedVoiceIndex - 1;
    }
    
    setSelectedVoiceIndex(newIndex);
    const selectedVoice = availableVoices[newIndex];
    console.log('üó£Ô∏è Voix chang√©e:', selectedVoice.name, selectedVoice.lang);
    
    // Test de la nouvelle voix
    speakMessage('Voix chang√©e');
  };
  
  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };
  
  return (
    <div className="cyberpunk-container">
      {/* Background anim√© */}
      <div className="cyberpunk-bg">
        <div className="grid-overlay"></div>
        <div className="particles">
          {[...Array(50)].map((_, i) => (
            <div key={i} className="particle" style={{
              left: `${Math.random() * 100}%`,
              animationDelay: `${Math.random() * 3}s`,
              animationDuration: `${3 + Math.random() * 4}s`
            }}></div>
          ))}
        </div>
      </div>
      
      {/* Header */}
      <motion.header 
        className="cyberpunk-header"
        initial={{ opacity: 0, y: -50 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 1 }}
      >
        <div className="header-left">
          <div className="jarvis-logo">
            <motion.div 
              className="logo-sphere"
              animate={{ 
                rotate: 360,
                scale: [1, 1.1, 1]
              }}
              transition={{ 
                rotate: { repeat: Infinity, duration: 10, ease: "linear" },
                scale: { repeat: Infinity, duration: 2, ease: "easeInOut" }
              }}
            >
              <div className="sphere-inner"></div>
            </motion.div>
            <div className="logo-text">
              <h1>J.A.R.V.I.S</h1>
              <p>Neural Interface v2.0</p>
            </div>
          </div>
        </div>
        
        <div className="header-right">
          {/* S√©lecteur de mode d'interaction */}
          <div className="mode-selector">
            <motion.button
              className={`mode-btn ${interactionMode === 'voice-only' ? 'active' : ''}`}
              onClick={() => changeInteractionMode('voice-only')}
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
              title="Mode vocal uniquement"
            >
              üé§
            </motion.button>
            <motion.button
              className={`mode-btn ${interactionMode === 'hybrid' ? 'active' : ''}`}
              onClick={() => changeInteractionMode('hybrid')}
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
              title="Mode hybride (vocal + texte)"
            >
              üìùüé§
            </motion.button>
            <motion.button
              className={`mode-btn ${interactionMode === 'text-only' ? 'active' : ''}`}
              onClick={() => changeInteractionMode('text-only')}
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
              title="Mode texte uniquement"
            >
              üìù
            </motion.button>
          </div>
          
          {/* S√©lecteur de voix */}
          {availableVoices.length > 1 && (
            <div className="voice-selector">
              <motion.button
                className="voice-btn"
                onClick={() => changeVoice('prev')}
                whileHover={{ scale: 1.1 }}
                whileTap={{ scale: 0.9 }}
                title="Voix pr√©c√©dente"
              >
                ‚óÄÔ∏è
              </motion.button>
              <span className="voice-info">
                {availableVoices[selectedVoiceIndex]?.name.substring(0, 15) || 'Voix'}
              </span>
              <motion.button
                className="voice-btn"
                onClick={() => changeVoice('next')}
                whileHover={{ scale: 1.1 }}
                whileTap={{ scale: 0.9 }}
                title="Voix suivante"
              >
                ‚ñ∂Ô∏è
              </motion.button>
            </div>
          )}
          
          <div className="status-indicators">
            <div className={`status-dot ${isConnected ? 'connected' : 'disconnected'}`}></div>
            <span className="status-text">{connectionStatus}</span>
            
            {isListening && (
              <motion.div 
                className="listening-indicator"
                animate={{ scale: [1, 1.2, 1] }}
                transition={{ repeat: Infinity, duration: 1 }}
              >
                üé§ √âCOUTE
              </motion.div>
            )}
            
            {isSpeaking && (
              <motion.div 
                className="speaking-indicator"
                animate={{ opacity: [0.5, 1, 0.5] }}
                transition={{ repeat: Infinity, duration: 0.8 }}
              >
                üîä PARLE
              </motion.div>
            )}
          </div>
        </div>
      </motion.header>
      
      {/* Zone de chat */}
      <main className="chat-area">
        <div className="messages-container">
          <AnimatePresence>
            {messages.length === 0 ? (
              <motion.div 
                className="welcome-screen"
                initial={{ opacity: 0, scale: 0.9 }}
                animate={{ opacity: 1, scale: 1 }}
                transition={{ duration: 1 }}
              >
                <motion.div 
                  className="welcome-orb"
                  animate={{ 
                    rotate: [0, 360],
                    scale: [1, 1.2, 1]
                  }}
                  transition={{ 
                    rotate: { repeat: Infinity, duration: 8, ease: "linear" },
                    scale: { repeat: Infinity, duration: 3, ease: "easeInOut" }
                  }}
                >
                  <div className="orb-ring ring-1"></div>
                  <div className="orb-ring ring-2"></div>
                  <div className="orb-ring ring-3"></div>
                  <div className="orb-core"></div>
                </motion.div>
                
                <h2>Bienvenue, Enzo</h2>
                <p>Syst√®me d'intelligence artificielle JARVIS op√©rationnel</p>
                <div className="mode-display">
                  <span className="current-mode">
                    Mode actuel: {
                      interactionMode === 'voice-only' ? 'üé§ Vocal Uniquement' :
                      interactionMode === 'text-only' ? 'üìù Texte Uniquement' :
                      'üìùüé§ Hybride (Vocal + Texte)'
                    }
                  </span>
                </div>
                <div className="welcome-features">
                  <span>üé§ {availableVoices.length} voix disponibles</span>
                  <span>üîä Synth√®se vocale premium</span>
                  <span>üß† IA neuromorphique</span>
                </div>
              </motion.div>
            ) : (
              <>
                {messages.map((msg) => (
                  <motion.div
                    key={msg.id}
                    className={`message-bubble ${msg.type} ${msg.isError ? 'error' : ''}`}
                    initial={{ opacity: 0, y: 50, scale: 0.8 }}
                    animate={{ opacity: 1, y: 0, scale: 1 }}
                    exit={{ opacity: 0, scale: 0.8 }}
                    transition={{ duration: 0.5 }}
                  >
                    <div className="message-avatar">
                      {msg.type === 'user' ? (
                        <div className="user-avatar">E</div>
                      ) : (
                        <motion.div 
                          className="ai-avatar"
                          animate={{ rotate: 360 }}
                          transition={{ repeat: Infinity, duration: 4, ease: "linear" }}
                        >
                          J
                        </motion.div>
                      )}
                    </div>
                    
                    <div className="message-content">
                      <div className="message-header">
                        <span className="sender-name">
                          {msg.type === 'user' ? 'Enzo' : 'J.A.R.V.I.S'}
                        </span>
                        <span className="message-time">
                          {msg.timestamp.toLocaleTimeString()}
                        </span>
                      </div>
                      
                      <div className="message-text">
                        {msg.content}
                      </div>
                    </div>
                  </motion.div>
                ))}
                
                {isLoading && (
                  <motion.div
                    className="message-bubble assistant loading"
                    initial={{ opacity: 0, y: 50 }}
                    animate={{ opacity: 1, y: 0 }}
                  >
                    <div className="message-avatar">
                      <motion.div 
                        className="ai-avatar"
                        animate={{ rotate: 360 }}
                        transition={{ repeat: Infinity, duration: 1, ease: "linear" }}
                      >
                        J
                      </motion.div>
                    </div>
                    
                    <div className="message-content">
                      <div className="loading-animation">
                        <motion.div className="typing-indicator">
                          <motion.span animate={{ opacity: [0, 1, 0] }} transition={{ repeat: Infinity, duration: 1, delay: 0 }}>‚óè</motion.span>
                          <motion.span animate={{ opacity: [0, 1, 0] }} transition={{ repeat: Infinity, duration: 1, delay: 0.3 }}>‚óè</motion.span>
                          <motion.span animate={{ opacity: [0, 1, 0] }} transition={{ repeat: Infinity, duration: 1, delay: 0.6 }}>‚óè</motion.span>
                        </motion.div>
                        <span className="processing-text">J.A.R.V.I.S traite votre demande...</span>
                      </div>
                    </div>
                  </motion.div>
                )}
                
                <div ref={messagesEndRef} />
              </>
            )}
          </AnimatePresence>
        </div>
      </main>
      
      {/* Zone de saisie */}
      <motion.footer 
        className="input-area"
        initial={{ opacity: 0, y: 50 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 1, delay: 0.5 }}
      >
        <form onSubmit={handleSubmit} className="input-form">
          <div className="input-container">
            <textarea
              value={inputMessage}
              onChange={(e) => setInputMessage(e.target.value)}
              onKeyDown={handleKeyDown}
              placeholder={
                !isConnected ? "Connexion au syst√®me..." :
                interactionMode === 'voice-only' ? "Mode vocal actif - Utilisez le micro" :
                interactionMode === 'text-only' ? "Tapez votre message..." :
                "Parlez √† J.A.R.V.I.S ou tapez..."
              }
              className="message-input"
              disabled={!isConnected || interactionMode === 'voice-only'}
              rows={1}
              style={{
                display: interactionMode === 'voice-only' ? 'none' : 'block'
              }}
            />
            
            <div className="input-controls" style={{
              right: interactionMode === 'voice-only' ? '50%' : '10px',
              transform: interactionMode === 'voice-only' ? 'translateX(50%)' : 'translateY(-50%)'
            }}>
              {isSpeaking && (
                <motion.button
                  type="button"
                  onClick={stopSpeaking}
                  className="control-btn stop-btn"
                  whileHover={{ scale: 1.1 }}
                  whileTap={{ scale: 0.9 }}
                  title="Arr√™ter la lecture"
                >
                  ‚èπÔ∏è
                </motion.button>
              )}
              
              <motion.button
                type="button"
                onClick={speakLastMessage}
                className="control-btn speak-btn"
                disabled={!isConnected || messages.filter(msg => msg.type === 'assistant').length === 0}
                whileHover={{ scale: 1.1 }}
                whileTap={{ scale: 0.9 }}
                title="Lire la derni√®re r√©ponse"
              >
                üîä
              </motion.button>
              
              <motion.button
                type="button"
                onClick={toggleAutoSpeak}
                className={`control-btn auto-speak-btn ${autoSpeak ? 'active' : ''}`}
                disabled={!isConnected}
                whileHover={{ scale: 1.1 }}
                whileTap={{ scale: 0.9 }}
                title={`Lecture automatique: ${autoSpeak ? 'ON' : 'OFF'}`}
              >
                {autoSpeak ? 'üîä' : 'üîá'}
              </motion.button>
              
              <motion.button
                type="button"
                onClick={toggleVoiceRecognition}
                className={`control-btn mic-btn ${isListening ? 'listening' : ''} ${
                  interactionMode === 'voice-only' ? 'voice-only-mic' : ''
                }`}
                disabled={!isConnected || interactionMode === 'text-only'}
                whileHover={{ scale: 1.1 }}
                whileTap={{ scale: 0.9 }}
                title={
                  interactionMode === 'voice-only' ? 'Appuyer pour parler (mode vocal)' :
                  interactionMode === 'text-only' ? 'Non disponible en mode texte' :
                  'Reconnaissance vocale'
                }
              >
                {isListening ? '‚èπÔ∏è' : 'üé§'}
              </motion.button>
              
              {interactionMode !== 'voice-only' && (
                <motion.button
                  type="submit"
                  disabled={!isConnected || !inputMessage.trim()}
                  className={`control-btn send-btn ${inputMessage.trim() && isConnected ? 'active' : ''}`}
                  whileHover={{ scale: 1.1 }}
                  whileTap={{ scale: 0.9 }}
                  title="Envoyer le message"
                >
                  ‚ö°
                </motion.button>
              )}
            </div>
          </div>
          
          {/* Affichage sp√©cial mode vocal uniquement */}
          {interactionMode === 'voice-only' && !isListening && !isLoading && (
            <motion.div 
              className="voice-only-prompt"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5 }}
            >
              <div className="voice-prompt-content">
                <motion.div 
                  className="pulse-circle"
                  animate={{ 
                    scale: [1, 1.2, 1],
                    opacity: [0.6, 1, 0.6]
                  }}
                  transition={{ 
                    repeat: Infinity, 
                    duration: 2,
                    ease: "easeInOut"
                  }}
                >
                  üé§
                </motion.div>
                <h3>Mode Vocal Actif</h3>
                <p>Cliquez sur le micro pour commencer √† parler</p>
                <div className="voice-tips">
                  <span>‚Ä¢ Parlez naturellement</span>
                  <span>‚Ä¢ Conversation fluide</span>
                  <span>‚Ä¢ R√©ponses vocales automatiques</span>
                </div>
              </div>
            </motion.div>
          )}
          
          {isListening && (
            <motion.div 
              className={`voice-feedback ${
                interactionMode === 'voice-only' ? 'voice-only-feedback' : ''
              }`}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -20 }}
            >
              <div className="sound-waves">
                {[...Array(7)].map((_, i) => (
                  <motion.div
                    key={i}
                    className="wave"
                    animate={{
                      height: [4, Math.random() * 25 + 10, 4],
                    }}
                    transition={{
                      repeat: Infinity,
                      duration: 0.8 + Math.random() * 0.4,
                      delay: i * 0.1
                    }}
                  />
                ))}
              </div>
              <span>
                {
                  interactionMode === 'voice-only' ? 'üé§ Mode vocal - Parlez maintenant...' :
                  'Parlez maintenant...'
                }
              </span>
              {interactionMode === 'voice-only' && (
                <div className="voice-only-hint">
                  <small>Votre voix sera directement trait√©e sans affichage texte</small>
                </div>
              )}
            </motion.div>
          )}
          
          {/* Instructions mode vocal */}
          {interactionMode === 'voice-only' && (
            <motion.div 
              className="mode-instructions"
              initial={{ opacity: 0 }}
              animate={{ opacity: 0.7 }}
              transition={{ delay: 1 }}
            >
              <small>
                üé§ Mode vocal: Conversation enti√®rement orale | 
                Voix: {availableVoices[selectedVoiceIndex]?.name || 'D√©faut'}
              </small>
            </motion.div>
          )}
        </form>
      </motion.footer>
    </div>
  );
};

export default CyberpunkJarvisInterface;