networks:
  jarvis_network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
          gateway: 172.20.0.1
    external: false
    attachable: true
    driver_opts:
      com.docker.network.bridge.name: jarvis-br0
      com.docker.network.bridge.enable_icc: "true"
      com.docker.network.bridge.enable_ip_masquerade: "true"
      com.docker.network.driver.mtu: 1500

services:
  # Jarvis Secrets Daemon - Secure secrets management
  jarvis-secretsd:
    build:
      context: ./jarvis-secretsd
      dockerfile: Dockerfile.runtime
    container_name: jarvis_secretsd
    env_file:
      - ./jarvis-secretsd/.env
    networks:
      jarvis_network:
        ipv4_address: 172.20.0.5
    ports:
      - "127.0.0.1:8081:8081"
    volumes:
      # Mount local migrated data to container
      - ./jarvis-secretsd/run/secrets:/opt/jarvis/secrets
      - ./jarvis-secretsd/run/audit:/opt/jarvis/audit
      - ./jarvis-secretsd/run/master.key:/opt/jarvis/master.key
      - ./jarvis-secretsd/config.toml:/etc/jarvis-secretsd/config.toml:ro
      - ./jarvis-secretsd/policy.yaml:/etc/jarvis-secretsd/policy.yaml:ro
    restart: unless-stopped
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:8081/healthz" ]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 10s
    security_opt:
      - no-new-privileges:true
    read_only: false
    tmpfs:
      - /tmp:noexec,nosuid

  # Container 1: STT API (Speech-to-Text) - Premier dans le schéma
  stt-api:
    build:
      context: .
      dockerfile: services/stt/Dockerfile
    container_name: jarvis_stt_api
    env_file:
      - ./services/stt/.env
    networks:
      jarvis_network:
        ipv4_address: 172.20.0.10
    ports:
      - "8003:8003"
    volumes:
      - ./services/stt:/app
      - ./models/stt:/app/models/stt
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:8003/health" ]
      interval: 30s
      timeout: 10s
      retries: 5

  # Container 2: TTS API (Text-to-Speech) - Deuxième dans le schéma
  tts-api:
    build:
      context: .
      dockerfile: services/tts/Dockerfile
    container_name: jarvis_tts_api
    env_file:
      - ./services/tts/.env
    networks:
      jarvis_network:
        ipv4_address: 172.20.0.20
    ports:
      - "8002:8002"
    volumes:
      - ./services/tts:/app
      - ./models/tts:/app/models/tts
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:8002/health" ]
      interval: 30s
      timeout: 10s
      retries: 5

  # Container 3: Ollama Container - Troisième dans le schéma
  ollama:
    image: ollama/ollama:latest
    container_name: jarvis_ollama
    networks:
      jarvis_network:
        ipv4_address: 172.20.0.30
    ports:
      - "11435:11434"
    volumes:
      - ollama_data:/root/.ollama
    restart: unless-stopped
    environment:
      - OLLAMA_ORIGINS=*
      - OLLAMA_HOST=0.0.0.0
    # GPU désactivé - Mode CPU uniquement
    # deploy:
    #   resources:
    #     reservations:
    #       devices:
    #         - driver: nvidia
    #           count: 1
    #           capabilities: [gpu]
    healthcheck:
      test: [ "CMD", "bash", "-lc", "ollama --version >/dev/null 2>&1" ]
      interval: 30s
      timeout: 10s
      retries: 5

  # Container 4: Rust Core Backend (Main Backend Logic) - Quatrième dans le schéma
  backend:
    build:
      context: ./core
      dockerfile: Dockerfile
    container_name: jarvis_backend
    env_file:
      - ./core/.env
    networks:
      jarvis_network:
        ipv4_address: 172.20.0.40
    ports:
      - "8100:8100"
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '2.0'
        reservations:
          memory: 512M
          cpus: '0.5'
    volumes:
      - ./models:/app/models
      - ./logs:/app/logs
      - ./data:/app/data
      # ./backend:/app volume supprimé pour éviter d'écraser les fichiers buildés
      # ./memory:/app/memory volume supprimé pour éviter d'écraser les fichiers buildés
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      ollama:
        condition: service_healthy
      qdrant:
        condition: service_healthy
      timescale:
        condition: service_healthy
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:8100/health" ]
      interval: 30s
      timeout: 10s
      retries: 5

  open-webui:
    build:
      context: ./services/open-webui
      dockerfile: Dockerfile
    container_name: jarvis_open_webui
    networks:
      jarvis_network:
        ipv4_address: 172.20.0.60
    ports:
      - "3000:8080"
    environment:
      # Secretsd Configuration
      - SECRETSD_URL=http://jarvis-secretsd:8081
      - CLIENT_ID=open-webui
      # Ollama Configuration
      - OLLAMA_BASE_URL=http://jarvis_ollama:11434
      - OLLAMA_API_BASE_URL=http://jarvis_ollama:11434
      # Memory / RAG Configuration
      - VECTOR_DB=qdrant
      - QDRANT_URI=http://jarvis_qdrant:6333
      # Jarvis Backend Integration
      - BACKEND_URL=http://jarvis_backend:8100
      # Audio STT Configuration (OpenAI-compatible)
      - AUDIO_STT_ENGINE=openai
      - AUDIO_STT_OPENAI_API_BASE_URL=http://jarvis_backend:8100/v1
      - AUDIO_STT_MODEL=whisper-1
      # Audio TTS Configuration (OpenAI-compatible)
      - AUDIO_TTS_ENGINE=openai
      - AUDIO_TTS_OPENAI_API_BASE_URL=http://jarvis_backend:8100/v1
      - AUDIO_TTS_MODEL=tts-1
      - AUDIO_TTS_VOICE=alloy
      - AUDIO_TTS_SPLIT_ON=punctuation
      # Force OpenAI engine even if UI shows different options
      - AUDIO_OPENAI_API_KEYS=dummy
    volumes:
      - open_webui_data:/app/backend/data
    restart: unless-stopped
    depends_on:
      jarvis-secretsd:
        condition: service_healthy
      ollama:
        condition: service_healthy
      backend:
        condition: service_healthy

  # PyO3 Rust-Python Bridge
  pyo3-bridge:
    build:
      context: ./backend-pyo3-bridge
      dockerfile: Dockerfile
    container_name: jarvis_pyo3_bridge
    env_file:
      - ./backend-pyo3-bridge/.env
    networks:
      jarvis_network:
        ipv4_address: 172.20.0.35
    ports:
      - "8005:8005"
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: [ "CMD", "python3", "-c", "import jarvis_bridge; print('OK')" ]
      interval: 30s
      timeout: 10s
      retries: 5

  # Services de support
  postgres:
    image: postgres:15
    container_name: jarvis_postgres
    networks:
      jarvis_network:
        ipv4_address: 172.20.0.100
    ports:
      - "5432:5432"
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-jarvis_db}
      POSTGRES_USER: ${POSTGRES_USER:-jarvis}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U jarvis -d jarvis_db" ]
      interval: 30s
      timeout: 10s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: jarvis_redis
    networks:
      jarvis_network:
        ipv4_address: 172.20.0.110
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped
    healthcheck:
      test: [ "CMD", "redis-cli", "ping" ]
      interval: 30s
      timeout: 10s
      retries: 5

  # Qdrant Vector Database - Memoire vectorielle neuromorphique
  qdrant:
    image: qdrant/qdrant:latest
    container_name: jarvis_qdrant
    networks:
      jarvis_network:
        ipv4_address: 172.20.0.120
    ports:
      - "6333:6333" # API REST
      - "6334:6334" # gRPC (optionnel)
    environment:
      - QDRANT__SERVICE__HTTP_PORT=6333
      - QDRANT__SERVICE__GRPC_PORT=6334
      - QDRANT__STORAGE__PERFORMANCE__MAX_SEARCH_THREADS=4
      - QDRANT__SERVICE__ENABLE_CORS=true
    volumes:
      - qdrant_data:/qdrant/storage
      - ./config/qdrant_config.yaml:/qdrant/config/production.yaml
    restart: unless-stopped
    healthcheck:
      test: [ "CMD-SHELL", "bash -c '</dev/tcp/127.0.0.1/6333'" ]
      interval: 30s
      timeout: 10s
      retries: 5

  # TimescaleDB - Memoire temporelle pour logs et metriques
  timescale:
    image: timescale/timescaledb:latest-pg15
    container_name: jarvis_timescale
    networks:
      jarvis_network:
        ipv4_address: 172.20.0.130
    environment:
      POSTGRES_DB: ${TIMESCALE_DB:-jarvis_timeseries}
      POSTGRES_USER: ${TIMESCALE_USER:-jarvis}
      POSTGRES_PASSWORD: ${TIMESCALE_PASSWORD}
      TIMESCALEDB_TELEMETRY: off
    volumes:
      - timescale_data:/var/lib/postgresql/data
    restart: unless-stopped
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U jarvis -d jarvis_timeseries" ]
      interval: 30s
      timeout: 10s
      retries: 5

volumes:
  secretsd_vault:
  secretsd_audit:
  postgres_data:
  redis_data:
  ollama_data:
  qdrant_data:
  timescale_data:
  open_webui_data:


