pipeline {
    agent any
    
    environment {
        DOCKER_REGISTRY = 'localhost:5000'
        PROJECT_NAME = 'jarvis'
        BRANCH_NAME = env.BRANCH_NAME ?: 'main'
    }
    
    tools {
        nodejs 'NodeJS-18'
        dockerTool 'Docker'
    }
    
    stages {
        stage(' Checkout') {
            steps {
                echo ' Récupération du code source...'
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: 'git rev-parse --short HEAD',
                        returnStdout: true
                    ).trim()
                }
            }
        }
        
        stage(' Install Dependencies') {
            parallel {
                stage('Backend Dependencies') {
                    steps {
                        dir('backend') {
                            sh '''
                                echo " Installation dépendances Python..."
                                python3 -m venv venv
                                source venv/bin/activate
                                pip install -r requirements.txt
                            '''
                        }
                    }
                }
                stage('Services Dependencies') {
                    steps {
                        script {
                            ['stt', 'tts'].each { service ->
                                dir("services/${service}") {
                                    sh '''
                                        echo " Installation dépendances pour ''' + service + '''..."
                                        python3 -m venv venv
                                        source venv/bin/activate
                                        pip install -r requirements.txt
                                    '''
                                }
                            }
                        }
                    }
                }
                stage('Interface Dependencies') {
                    steps {
                        dir('services/interface') {
                            sh '''
                                echo " Installation dépendances Interface..."
                                python3 -m venv venv
                                source venv/bin/activate
                                pip install -r requirements.txt
                            '''
                        }
                    }
                }
            }
        }
        
        stage(' Tests') {
            parallel {
                stage('Backend Tests') {
                    steps {
                        dir('backend') {
                            sh '''
                                echo " Tests backend Python..."
                                source venv/bin/activate
                                # Tests basiques si le dossier tests existe
                                if [ -d "tests" ]; then
                                    python -m pytest tests/ --junitxml=test-results.xml --cov=. --cov-report=xml
                                else
                                    echo " Pas de tests unitaires configurés, validation syntaxe..."
                                    python -m py_compile main.py
                                fi
                            '''
                        }
                    }
                    post {
                        always {
                            script {
                                if (fileExists('backend/test-results.xml')) {
                                    publishTestResults testResultsPattern: 'backend/test-results.xml'
                                }
                                if (fileExists('backend/coverage.xml')) {
                                    publishCoverage adapters: [coberturaAdapter('backend/coverage.xml')]
                                }
                            }
                        }
                    }
                }
                stage('Services Tests') {
                    steps {
                        script {
                            echo " Tests services Jarvis..."
                            sh '''
                                echo " Tests basiques services..."
                                # Tests health check des endpoints
                                python3 -c "print('Services tests completed')"
                            '''
                        }
                    }
                }
                stage('Security Scan') {
                    steps {
                        sh '''
                            echo " Scan sécurité avec Trivy..."
                            docker run --rm -v $(pwd):/workspace aquasec/trivy:latest fs /workspace
                        '''
                    }
                }
            }
        }
        
        stage(' Build Docker Images') {
            steps {
                script {
                    echo " Construction images Docker..."
                    
                    // Build backend
                    sh """
                        echo " Build backend..."
                        docker build -t ${PROJECT_NAME}-backend:${env.GIT_COMMIT_SHORT} ./backend/
                        docker tag ${PROJECT_NAME}-backend:${env.GIT_COMMIT_SHORT} ${PROJECT_NAME}-backend:latest
                    """
                    
                    // Build services
                    def services = ['stt', 'tts', 'interface']
                    def builds = [:]
                    
                    for (service in services) {
                        builds[service] = {
                            sh """
                                echo " Build ${service}..."
                                docker build -t ${PROJECT_NAME}-${service}:${env.GIT_COMMIT_SHORT} ./services/${service}/
                                docker tag ${PROJECT_NAME}-${service}:${env.GIT_COMMIT_SHORT} ${PROJECT_NAME}-${service}:latest
                            """
                        }
                    }
                    parallel builds
                }
            }
        }
        
        stage(' Quality Gates') {
            steps {
                script {
                    echo " Vérifications qualité..."
                    sh '''
                        echo " Code quality avec SonarQube..."
                        # SonarQube scan ici
                        
                        echo " Métriques de performance..."
                        # Performance tests ici
                    '''
                }
            }
        }
        
        stage(' Deploy to Staging') {
            when {
                branch 'develop'
            }
            steps {
                script {
                    echo " Déploiement staging..."
                    sh '''
                        echo " Push images vers registry..."
                        docker push ${DOCKER_REGISTRY}/${PROJECT_NAME}-backend:${GIT_COMMIT_SHORT}
                        docker push ${DOCKER_REGISTRY}/${PROJECT_NAME}-interface:${GIT_COMMIT_SHORT}
                        
                        echo " Déploiement via ArgoCD..."
                        # Trigger ArgoCD sync
                        kubectl patch application jarvis-staging -n argocd --type merge -p '{"spec":{"source":{"targetRevision":"'${GIT_COMMIT_SHORT}'"}}}'
                    '''
                }
            }
        }
        
        stage(' Deploy to Production') {
            when {
                branch 'main'
            }
            steps {
                script {
                    echo " Déploiement production..."
                    input message: 'Deploy to production?', ok: 'Deploy'
                    
                    sh '''
                        echo " Push images production..."
                        docker tag ${DOCKER_REGISTRY}/${PROJECT_NAME}-backend:${GIT_COMMIT_SHORT} ${DOCKER_REGISTRY}/${PROJECT_NAME}-backend:stable
                        docker push ${DOCKER_REGISTRY}/${PROJECT_NAME}-backend:stable
                        
                        echo " Déploiement production via ArgoCD..."
                        kubectl patch application jarvis-production -n argocd --type merge -p '{"spec":{"source":{"targetRevision":"stable"}}}'
                    '''
                }
            }
        }
    }
    
    post {
        always {
            echo ' Nettoyage...'
            sh 'docker system prune -f'
            cleanWs()
        }
        success {
            echo ' Pipeline exécuté avec succès!'
            slackSend(
                channel: '#jarvis-ci',
                color: 'good',
                message: " Jarvis build ${env.BUILD_NUMBER} succeeded on ${env.BRANCH_NAME}"
            )
        }
        failure {
            echo ' Pipeline échoué!'
            slackSend(
                channel: '#jarvis-ci',
                color: 'danger',
                message: " Jarvis build ${env.BUILD_NUMBER} failed on ${env.BRANCH_NAME}"
            )
        }
    }
}